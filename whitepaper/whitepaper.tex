\documentclass{article}



\title{HIPSTER-C:\\
       Happy Imperative Programming System for Teens on the Edge of Regular Culture}

\begin{document}
\maketitle


\begin{abstract}
  HIPSTER-C is an imperative language for application programming closer to the bare metal than traditional interpreted languages. HIPSTER-C aims to bring much of the lower level functionality of systems programming to a higher level interface by acting as a C language translator.
\end{abstract} 



\section{Background}
Small embedded devices are being deployed at a very rapid place to all sectors of the industry. These devices control a diverse mix of hardware, requiring many software systems to be developed. \par
One common characteristic of these devices is that they have very little working memory, sometimes as little as tens or hundreds of kilobytes. Running an interpreted language on these devices requires a large amount of working memory for the program and the interpreter or runtime. \par
HIPSTER-C aims to be a general purpose platform independent high level language for devices with small memory footprints. HIPSTER-C includes basic components of procedural and functional languages, with the aim to increase the scalablity, ease of use, and security of systems languages. \par 
HIPSTER-C is translated to C, and then compiled to machine code. HIPSTER-C therefore can take advantage of C features and libraries while maintaining a high level interface suited for quick scripting projects and learning. 

\section{Related Work}
\subsection{Lua}
Lua is a multipurpose scripting language that combines parts of functional and imperative programming. Lua is designed for systems scripting work, and has also been used as a backend multi-language software and games. 
\subsection{Rust}
Rust is a systems programming language that aims to solve some of the problems with C memory access. Rust supports both functional and imperative paradigms.




\section{Syntax}
HIPSTER-C uses a simple syntax that tries to minimize cluttered nested block statements and overuse of parentheses or ``left/right'' matching brackets. The beginning of statements are treated as definitions by default, requiring keywords like \textit{call} for calling function.  


\subsection{Variables and Operators}
HIPSTER-C supports operators:\par
Arithmetic: \texttt{+, -, *, /, \%}\par 
Assignment: \texttt{=}\par
Equality Testing: \texttt{==, !=}\par
Order Relations: \texttt{<, <=, >, >=}\par
Sequencing: whitespace
Subexpression Grouping: \texttt{( )}\par
Type checking: \texttt{:}


\begin{verbatim}
int y = input;
int x = input + 9;
double z = input / 10;
\end{verbatim}


\subsection{Control Flow}
HIPSTER-C has basic control flow statements based on C

\begin{verbatim}
if 2 < 9;
   //we always do this
end; 

if 9 < 2;

else;
    //we always do this
end;

if 9<0;

else if true;
    //we always do this
else;

end; 

for 0 to 100;
   z = z + 1;
end;

\end{verbatim}

\subsection{Types}
Numeric types include all basic primitives from C. Type checking is enforced however, and some type conflicts will result in a compiler warning or error
\begin{verbatim}
int:inttype = 4; //int
double:doubletype = call double inttype; // 4.0 
int:new; //defaults to 0 
new = doubletype; //won't compile. Loss of precision
new = call int doubletype; //floor(doubletype) 
\end{verbatim}


\subsection{Strings}
Strings in HIPSTER-C are based off of c strings, but using a HIPSTER-C array of characters instead of a C array. 
\begin{verbatim}
string stype = 'hi there'; //strings are null terminated HIPSTER-C arrays
char c = 'x';
x = stype 3; //x is now 't'
\end{verbatim}


\subsection{Functions}
Functions are declared with the \textit{function} keyword, with a single return value and a set number of parameters. Function overloading is allowed. Functions are called with the \textit{call} keyword. If \textit{call} is not used, a function can be treated as a type and passed to other functions, much like C function pointers or watered down lisp functions. 
\begin{verbatim}

function void test void; 
   return void;
end;

function int test2 int:input; 
   return input;
end;

//function that takes an function as a parameter and calls it
function int functioncruncher function:func;
   call func; //execute function from arguments 
   return 0;
end; 

call test2 3; //calling a function with call keyword
\end{verbatim}



\end{document} 
